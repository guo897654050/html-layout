<!doctype html>
<html class="no-js" lang="en">
	<head>
		<meta charset="utf-8">
		<title>Our first responsive web page with HTML5 and CSS3</title>
		<meta name="description" content="A basic responsive web page – an example from Chapter 1">
		<meta name="viewport" content="width=device-width">
	</head>
	<style>
		img {
			border-radius: 50%;
			position: absolute;
			top: 0;
		}
		* {
			padding: 0;
			margin: 0;
		}
		section {
			width: 980px;
			background: #f5f5f5;
			box-shadow: 0 0 1px rgba(0,0,0,.4) inset;
			padding: 40px;
			box-sizing: border-box;
		}
		article {
			width: 49%;
			float: left;
			position: relative;
		}
		article:first-child{
			margin-right: 2%;
		}
		h1 {
			font-size: 32px;
			margin-bottom: 15px;
		}
		p {
			font-size: 15px;
			color: #777;
		}
		h1, p {
			width:65%;
			margin-left: 35%;
			font-family: Georgia, "Times New Roman", Times, serif;
		}
		/*通过堆父元素添加after伪类来清除浮动*/
		/*section:after {
			content: '';
			display: block;
			clear: both;
		}*/
		.clearfix:before, .clearfix:after {
			content: '';
			display: block;
		}
		.clearfix:after {
			clear: both;
		}
	</style>
	<body>
		<section class="clearfix">
			<article>
				<h1>rip van vlvle</h1>
				<p> 插入排序:
					如果用一个排序列表实现优先级队列，由于每次remove_min时间复杂度为o(1)，但每次add的时候与p的长度成正比,最坏也为n(n+1)/2即n^2
					最好为o(n),故插入排序最好时间o(n),最坏0(n^2)
				</p>
				<img src="logo3.jpg" width="100" height="100" alt='xxx'>
			</article>
			<article>
				<h1>rip van vlvle</h1>
				<p> 选择排序:
					如果使用未排序的列表来实现PositionList，由于每增加一个元素时间为o(1),因此pq_sort()在第一阶段的时间复杂度为o(n)，
					第二阶段 remove_min()操作的时间复杂度与P的大小成正比,由于每次重复的选取最小的元素，因此成为选择排序。
					P的其实大小为n，每次调用remove_min，有n=>0，总的为n(n+1)/2，即时间复杂度为n^2，顾总的时间复杂度为n^2
				</p>
				<img src="logo4.jpg" width="100" height="100" alt='xxx2'>
			</article>
		</section>
	</body>
</html>
